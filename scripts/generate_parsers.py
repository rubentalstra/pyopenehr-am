"""Generate committed ANTLR-derived parser code.

This script is intended for contributors only.

Policy:
- Grammar sources live in `grammars/`.
- Generated Python code is committed under `openehr_am/_generated/`.
- End-users installing the package should NOT need the ANTLR generator.

Prerequisites (contributors):
- A JVM (a launcher on PATH)
- ANTLR tool jar (e.g. `antlr-4.13.2-complete.jar`)

See `docs/dev/parsers.md` for details.
"""

import argparse
import os
import re
import shutil
import subprocess
import sys
import tempfile
from importlib import metadata
from pathlib import Path


def _find_antlr_grammars(grammars_dir: Path) -> list[Path]:
    return sorted(grammars_dir.rglob("*.g4"))


def _find_java() -> str | None:
    return shutil.which("java")


def _find_antlr4() -> str | None:
    # Often provided by `antlr4-tools` or OS packages.
    return shutil.which("antlr4")


def _resolve_antlr_jar(*, cli_value: str | None) -> Path | None:
    raw = cli_value or os.environ.get("ANTLR4_JAR")
    if not raw:
        return None
    jar = Path(raw).expanduser()
    if not jar.exists() or not jar.is_file():
        raise ValueError(f"ANTLR jar not found: {jar}")
    return jar


_ANTLR_JAR_VERSION_RE = re.compile(r"antlr-(\d+\.\d+\.\d+)-complete\.jar$")


def _antlr_runtime_version() -> str | None:
    try:
        return metadata.version("antlr4-python3-runtime")
    except metadata.PackageNotFoundError:
        return None


def _antlr_tool_version_from_jar(antlr_jar: Path) -> str | None:
    m = _ANTLR_JAR_VERSION_RE.search(antlr_jar.name)
    if not m:
        return None
    return m.group(1)


_ANTLR_TOOL_VERSION_LINE_RE = re.compile(
    r"ANTLR\s+Parser\s+Generator\s+(\d+\.\d+\.\d+)"
)


def _antlr_tool_version_from_antlr4_cmd(antlr4_cmd: str) -> str | None:
    # `antlr4 -version` typically prints e.g. "ANTLR Parser Generator 4.13.2".
    try:
        proc = subprocess.run(
            [antlr4_cmd, "-version"],
            check=True,
            text=True,
            capture_output=True,
        )
    except (OSError, subprocess.CalledProcessError):
        return None

    text = (proc.stdout or "") + "\n" + (proc.stderr or "")
    for line in text.splitlines():
        m = _ANTLR_TOOL_VERSION_LINE_RE.search(line)
        if m:
            return m.group(1)
    return None


def _require_matching_versions(*, tool: str | None, runtime: str | None) -> None:
    # Per ANTLR docs: tool and runtime must match to avoid subtle failures.
    if tool is None or runtime is None:
        return
    if tool != runtime:
        raise ValueError(
            "ANTLR tool/runtime version mismatch: "
            f"tool={tool!r} runtime={runtime!r}. "
            "Use the same ANTLR version for code generation and antlr4-python3-runtime."
        )


def _ensure_generated_package_scaffold(tmp_out: Path) -> None:
    # Deterministic package marker so generated code is importable.
    init_py = tmp_out / "__init__.py"
    init_py.write_text(
        "# Generated by scripts/generate_parsers.py; do not edit.\n",
        encoding="utf-8",
    )


def _run_antlr(
    *,
    java: str | None,
    antlr_jar: Path | None,
    antlr4_cmd: str | None,
    grammars: list[Path],
    grammars_dir: Path,
    out_dir: Path,
) -> None:
    # Keep the invocation deterministic:
    # - sorted grammar list
    # - exact output dir
    # - pinned language target
    base_args: list[str] = [
        "-Dlanguage=Python3",
        "-encoding",
        "UTF-8",
        "-listener",
        "-visitor",
        "-Xexact-output-dir",
        "-o",
        str(out_dir),
        "-package",
        "openehr_am._generated",
        "-lib",
        str(grammars_dir),
        *[str(p) for p in grammars],
    ]

    if antlr4_cmd is not None:
        subprocess.run([antlr4_cmd, *base_args], check=True)
        return

    if java is None or antlr_jar is None:
        raise ValueError(
            "ANTLR tool not configured. Provide --antlr-jar / ANTLR4_JAR or install an `antlr4` command."
        )
    subprocess.run([java, "-jar", str(antlr_jar), *base_args], check=True)


def _sync_generated_tree(*, tmp_out: Path, generated_dir: Path) -> None:
    # Remove previously generated artefacts but keep README.md (and any other
    # hand-written documentation).
    for child in generated_dir.iterdir():
        if child.name == "README.md":
            continue
        if child.is_dir():
            shutil.rmtree(child)
        else:
            child.unlink()

    # Copy new output in.
    for src in tmp_out.rglob("*"):
        rel = src.relative_to(tmp_out)
        dst = generated_dir / rel

        if src.is_dir():
            dst.mkdir(parents=True, exist_ok=True)
            continue

        dst.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy2(src, dst)

    _normalize_generated_python_headers(generated_dir)


_GENERATED_FROM_RE = re.compile(r"^(# Generated from )(.+?)( by ANTLR .*)$")


def _normalize_generated_python_headers(generated_dir: Path) -> None:
    """Make generated Python output deterministic across machines.

    ANTLR emits absolute paths to grammar files in the first-line header comment,
    which causes noisy diffs between contributors and CI. We rewrite that header
    to use a stable, repo-relative `grammars/...` path when possible.
    """

    for py in generated_dir.glob("*.py"):
        # Skip our own deterministic scaffold marker.
        if py.name == "__init__.py":
            continue

        text = py.read_text(encoding="utf-8")
        lines = text.splitlines(keepends=True)
        if not lines:
            continue

        m = _GENERATED_FROM_RE.match(lines[0].rstrip("\n"))
        if not m:
            continue

        prefix, raw_path, suffix = m.groups()
        normalized = raw_path.replace("\\\\", "/")
        anchor = "/grammars/"
        idx = normalized.rfind(anchor)
        if idx == -1:
            continue

        stable = normalized[idx + 1 :]
        new_first = f"{prefix}{stable}{suffix}\n"
        if lines[0] != new_first:
            lines[0] = new_first
            py.write_text("".join(lines), encoding="utf-8")


def main() -> int:
    parser = argparse.ArgumentParser(
        description=(
            "Generate ANTLR-derived Python parser code into openehr_am/_generated/. "
            "If no grammars are present, this is a no-op."
        ),
    )
    parser.add_argument(
        "--antlr-jar",
        help=(
            "Path to the ANTLR tool jar (e.g. antlr-4.13.2-complete.jar). "
            "Alternatively set ANTLR4_JAR."
        ),
    )
    parser.add_argument(
        "--antlr4",
        help=(
            "Path to an `antlr4` executable (if installed). If omitted, the generator "
            "uses --antlr-jar/ANTLR4_JAR when provided, otherwise it will try to find `antlr4` on PATH."
        ),
    )
    args = parser.parse_args()

    repo_root = Path(__file__).resolve().parents[1]
    grammars_dir = repo_root / "grammars"
    generated_dir = repo_root / "openehr_am" / "_generated"

    if not grammars_dir.exists():
        print(
            "scripts/generate_parsers.py: no grammars/ directory; nothing to generate"
        )
        return 0

    if not generated_dir.exists():
        raise SystemExit(
            "openehr_am/_generated/ is missing. Create it and commit generated code."
        )

    grammars = _find_antlr_grammars(grammars_dir)
    if not grammars:
        print("scripts/generate_parsers.py: no *.g4 grammars; nothing to generate")
        return 0

    # Determine tool selection.
    antlr4_cmd = Path(args.antlr4).expanduser() if args.antlr4 else None
    if antlr4_cmd is not None:
        if not antlr4_cmd.exists():
            print(
                f"scripts/generate_parsers.py: antlr4 executable not found: {antlr4_cmd}",
                file=sys.stderr,
            )
            return 2
        antlr4 = str(antlr4_cmd)
        antlr_jar = None
    else:
        try:
            antlr_jar = _resolve_antlr_jar(cli_value=args.antlr_jar)
        except ValueError as exc:
            print(f"scripts/generate_parsers.py: {exc}", file=sys.stderr)
            return 2

        antlr4 = None
        if antlr_jar is None:
            antlr4 = _find_antlr4()

    if antlr_jar is None and antlr4 is None:
        print(
            "scripts/generate_parsers.py: No ANTLR tool configured. "
            "Set ANTLR4_JAR or pass --antlr-jar, or install an `antlr4` executable. "
            "See docs/dev/parsers.md.",
            file=sys.stderr,
        )
        return 2

    runtime_ver = _antlr_runtime_version()
    tool_ver: str | None
    if antlr_jar is not None:
        tool_ver = _antlr_tool_version_from_jar(antlr_jar)
    else:
        tool_ver = _antlr_tool_version_from_antlr4_cmd(antlr4) if antlr4 else None

    try:
        _require_matching_versions(tool=tool_ver, runtime=runtime_ver)
    except ValueError as exc:
        print(f"scripts/generate_parsers.py: {exc}", file=sys.stderr)
        return 2

    java = None
    if antlr_jar is not None:
        java = _find_java()
        if java is None:
            print(
                "scripts/generate_parsers.py: JVM launcher not found on PATH. "
                "The ANTLR code generator is a JVM tool and requires a JVM to regenerate parsers. "
                "See docs/dev/parsers.md.",
                file=sys.stderr,
            )
            return 2

    with tempfile.TemporaryDirectory(prefix="openehr_am_antlr_") as tmp:
        tmp_out = Path(tmp) / "out"
        tmp_out.mkdir(parents=True, exist_ok=True)

        try:
            _run_antlr(
                java=java,
                antlr_jar=antlr_jar,
                antlr4_cmd=antlr4,
                grammars=grammars,
                grammars_dir=grammars_dir,
                out_dir=tmp_out,
            )
        except subprocess.CalledProcessError as exc:
            print(
                f"scripts/generate_parsers.py: ANTLR generation failed (exit {exc.returncode}).",
                file=sys.stderr,
            )
            return 1
        _ensure_generated_package_scaffold(tmp_out)
        _sync_generated_tree(tmp_out=tmp_out, generated_dir=generated_dir)

    print(
        "scripts/generate_parsers.py: generated output updated in openehr_am/_generated/"
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
